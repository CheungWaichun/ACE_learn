## C++网络编程 卷1 运用ACE和模式消除复杂性

### 第9章 读书笔记

封装不同OS的底层多线程机制，提供一致、可移植的C++类接口（ACE_Thread_Manager, ACE_Sched_Params, ACE_TSS）。



| ACE类 | 说明 |
| :---: | :----: |
| ACE_Thread_Manager | 创建和管理线程 |
| ACE_Sched_Params | 获得线程优先级相关的值，供ACE_OS::Sched_params()方法使用，控制线程的属性值（指定优先级、调度策略、策略范围等） |
| ACE_TSS | 封装“线程专有存储”机制，甚至能在缺乏TSS支持的平台上模拟TSS。使上层无需考虑同步问题。 |

#### 9.1 ACE_Thread_Manager，使用 ACE_THREAD_MANAGER 进行线程管理  

多线程应用程序在不同OS间的可移植性问题：
1.语法
 功能相同的API名字不同
2.语义
各个OS的线程机制在语义上具有多样性：detached thread
3.线程删除机制



在不同的平台上，有着若干不同的用于线程管理的接口。其中包括 POSIX pthreads 接口、Solaris 线 程、Win32 线程等等。这些接口提供了相同或是相似的功能，但是它们的 API 的差别却极为悬殊。这就 导致了困难、麻烦和易错的编程，因为应用程序员必须熟悉不同平台上的若干接口。而且，这样写下的 程序，是不可移植和不灵活的。 ACE_Thread 提供了对 OS 的线程调用的简单包装，这些调用处理线程创建、挂起、取消和删除等问 题。它提供给应用程序员一个简单易用的接口，可以在不同的线程 API 间移植。ACE_Thread 是非常“瘦” 的包装，有着很少的开销。其大多数方法都是内联的，因而等价于对底层 OS 专有线程接口的直接调用。 ACE_Thread 中的所有方法都是静态的，而且该类一般不进行实例化。



在该类中没有可供我们调用的管理功能，用以在内部记住应 用所派生的线程的 ID。这使得我们难以联接（join()）、杀死（kill()）或是一般性地管理我们派生的线程。 在本章后面讲述的 ACE_Thread_Manager 缓解了这些问题，一般说来，应该使用 ACE_Thread_Manager 而不是线程包装 API。



|方法|说明|
| :---: | :---: |
|spawn()|创建一个新的控制线程，并传递给它一个“函数”和“函数的参数”，作为线程执行的入口点。|
|spawn_n()|创建n个“同属一个线程组”的新线程，其他线程会等待这整组线程退出。|
|wait()|阻塞，直至线程管理器中的所有线程都已退出，并获得所有“可连接”线程的退出状态为止。|
|join()|等待某一线程退出，并获得其退出状态。|
|cancel_all()|请求ACE_Thred_Manager对象管理的线程全部退出。|
|testcancel()|询问某一线程是否已被请求退出。|
|exit()|退出一个线程，并释放这个线程的资源。|
|close()|关闭并释放所有被管理线程的资源。|
|instance()|这是一个静态方法，返回一个指向ACE_Thread_Manager singleton的指针。|



#### 9.3 线程专有存储（Thread Specific Storage）  

