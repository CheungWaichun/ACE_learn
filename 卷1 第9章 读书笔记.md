## C++网络编程 卷1 运用ACE和模式消除复杂性

## 第9章 读书笔记

封装不同OS的底层多线程机制，提供一致、可移植的C++类接口（ACE_Thread_Manager, ACE_Sched_Params, ACE_TSS）。



| ACE类 | 说明 |
| :---: | :----: |
| ACE_Thread_Manager | 创建和管理线程 |
| ACE_Sched_Params | 获得线程优先级相关的值，供ACE_OS::Sched_params()方法使用，控制线程的属性值（指定优先级、调度策略、策略范围等） |
| ACE_TSS | 封装“线程专有存储”机制，甚至能在缺乏TSS支持的平台上模拟TSS。使上层无需考虑同步问题。 |

### 9.1 ACE_Thread_Manager，使用 ACE_THREAD_MANAGER 进行线程管理  

多线程应用程序在不同OS间的可移植性问题：
1.语法
 功能相同的API名字不同
2.语义
各个OS的线程机制在语义上具有多样性：detached thread
3.线程删除机制



在不同的平台上，有着若干不同的用于线程管理的接口。其中包括 POSIX pthreads 接口、Solaris 线 程、Win32 线程等等。这些接口提供了相同或是相似的功能，但是它们的 API 的差别却极为悬殊。这就 导致了困难、麻烦和易错的编程，因为应用程序员必须熟悉不同平台上的若干接口。而且，这样写下的 程序，是不可移植和不灵活的。 ACE_Thread 提供了对 OS 的线程调用的简单包装，这些调用处理线程创建、挂起、取消和删除等问 题。它提供给应用程序员一个简单易用的接口，可以在不同的线程 API 间移植。ACE_Thread 是非常“瘦” 的包装，有着很少的开销。其大多数方法都是内联的，因而等价于对底层 OS 专有线程接口的直接调用。 ACE_Thread 中的所有方法都是静态的，而且该类一般不进行实例化。



在该类中没有可供我们调用的管理功能，用以在内部记住应 用所派生的线程的 ID。这使得我们难以联接（join()）、杀死（kill()）或是一般性地管理我们派生的线程。 在本章后面讲述的 ACE_Thread_Manager 缓解了这些问题，一般说来，应该使用 ACE_Thread_Manager 而不是线程包装 API。



|方法|说明|
| :---: | :---: |
|spawn()|创建一个新的控制线程，并传递给它一个“函数”和“函数的参数”，作为线程执行的入口点。|
|spawn_n()|创建n个“同属一个线程组”的新线程，其他线程会等待这整组线程退出。|
|wait()|阻塞，直至线程管理器中的所有线程都已退出，并获得所有“可连接”线程的退出状态为止。|
|join()|等待某一线程退出，并获得其退出状态。|
|cancel_all()|请求ACE_Thred_Manager对象管理的线程全部退出。|
|testcancel()|询问某一线程是否已被请求退出。|
|exit()|退出一个线程，并释放这个线程的资源。|
|close()|关闭并释放所有被管理线程的资源。|
|instance()|这是一个静态方法，返回一个指向ACE_Thread_Manager singleton的指针。|



ACE_Thread_Manager::spawn()方法：
|标志|说明|
|:---:|:---:|
|THR_SCOPE_SYSTEM|系统调度争用，与新核心线程绑定。|
|THR_SCOPE_PROCESS|进程调度争用，作为用户线程。|
|THR_NEW_LWP|进程的并发属性。“未绑定线程”：默认增1，添加一个核心线程到线程池以运行用户线程。|
|THR_DETACHED|创建“分离”线程。线程终止时ID和资源会被OS自动回收，与THR_JOINABLE标志相反。|
|THR_JOINABLE|创建“可连接”线程，其他线程可以通过ACE_Thread_Manager::join()方法得到它的退出状态。所以ACE线程创建方法的默认行为是THR_JOINABLE。|


### 9.2 ACE_Sched_Params类
#### ACE_OS::sched_params() wrapper method封装了与调度相关的函数
ACE_OS::thr_prio()
ACE_OS::thr_setprio()
#### ACE_Sched_Params wrapper facade类提供了这个方法所用到的值
|方法|说明|
|:---:|:---:|
|ACE_Sched_Params()|设置线程的调度策略、优先级、范围和量|
|priority_min()|返回某一调度策略和范围的最低优先级|
|priority_max()|返回最高优先级|
|next_priority()|返回下一个较高的优先级|
|previous_priority()|返回下一个较低的优先级|


### 9.3 线程专有存储TSS类（Thread Specific Storage）  
在线程专有存储中，对象可像逻辑上的静态或全局变量一样被访问；而实际上（物理上）它对线程来说是私有的。把全局或静态数据放在TSS中，就可将同步所导致的开销降到最低。这是使用 TSS 的主要好处。
|方法|说明|
|:---:|:---:|
|operator->()|得到“和TSS键相关联”的“线程专有”对象。|
|cleanup()|静态方法：线程退出时删除TSS对象。|