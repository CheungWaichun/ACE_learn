## C++网络编程 卷1 运用ACE和模式消除复杂性

## 第9章 读书笔记

### 9.1 概述

封装不同OS的底层多线程机制，提供一致、可移植的C++类接口（ACE_Thread_Manager, ACE_Sched_Params, ACE_TSS）。



| ACE类 | 说明 |
| :---: | :----: |
| ACE_Thread_Manager | 创建和管理线程 |
| ACE_Sched_Params | 封装了进程、线程“调度”相关的属性，供ACE_OS::Sched_params()方法使用，用于控制线程的属性值（指定优先级、调度策略、策略范围等） |
| ACE_TSS | 封装“线程专有存储”机制 |

优点：

1. 封装OS间不同的多线程语法和语义，提供统一的接口，确保可移植性
2. 将一组线程作为一个有机的集合来管理
3. 管理线程的调度策略和优先级
4. 高效地使用和管理TSS



### 9.2 ACE_Thread

在不同的平台上，有着若干不同的用于线程管理的接口。其中包括 POSIX pthreads 接口、Solaris 线 程、Win32 线程等等。这些接口提供了相同或是相似的功能，但是它们的 API 的差别却极为悬殊。这就 导致了困难、麻烦和易错的编程，因为应用程序员必须熟悉不同平台上的若干接口。而且，这样写下的程序，是不可移植和不灵活的。 

ACE_Thread 提供了对 OS 的线程调用的简单包装，这些调用处理线程创建、挂起、取消和删除等问题。它提供给应用程序员一个简单易用的接口，可以在不同的线程 API 间移植。ACE_Thread 是非常“瘦” 的包装，有着很少的开销。其大多数方法都是内联的，因而等价于对底层 OS 专有线程接口的直接调用。 ACE_Thread 中的所有方法都是静态的，而且该类一般不进行实例化。

在该类中没有可供我们调用的管理功能，用以在内部记住应用所派生的线程的 ID。这使得我们难以联接（join()）、杀死（kill()）或是一般性地管理我们派生的线程。 ACE_Thread_Manager 缓解了这些问题，一般说来，应该使用 ACE_Thread_Manager 而不是线程包装 API。



ace/Thread.h 中的 ACE_Thread 类简介:

```cpp
/**
 * @class ACE_Thread
 *
 * @brief Provides a wrapper for threads.
 *
 * This class provides a common interface that is mapped onto
 * POSIX Pthreads, Solaris threads, Win32 threads, VxWorks
 * threads, or pSoS threads.  Note, however, that it is
 * generally a better idea to use the ACE_Thread_Manager
 * programming API rather than the <ACE_Thread> API since the
 * thread manager is more powerful.
 */
```



### 9.3 ACE_Thread_Manager

“多线程”机制引入了两种“不确定性”，使得难以编写出可移植的应用程序：

1. 语法

   原始的 OS 线程 API 往往存在语法上的差异，因而不具可移植性，即使它们提供的功能相同。

   例如：Win32的CreateThread() 和 Pthreads 的 pthread_create()

2. 语义

   各个 OS 线程机制在语义上存在多样性。

   例如，不同系统对于 detached thread 和 joinable thread 具有不同的支持；不同的“线程删除”机制：“骤死删除”和“异步删除”。



ACE_Thread_Manager类的接口：

|方法|说明|
| :---: | :---: |
|spawn()|创建一个新的控制线程，并传递给它一个“函数”和“函数的参数”，作为线程执行的入口点。|
|spawn_n()|创建n个“同属一个线程组”的新线程，其他线程会等待这整组线程退出。|
|wait()|阻塞，直至线程管理器中的所有线程都已退出，并获得所有“可连接”线程的退出状态为止。|
|join()|等待某一线程退出，并获得其退出状态。|
|cancel_all()|请求ACE_Thred_Manager对象管理的线程全部退出。|
|testcancel()|询问某一线程是否已被请求退出。|
|exit()|退出一个线程，并释放这个线程的资源。|
|close()|关闭并释放所有被管理线程的资源。|
|instance()|这是一个静态方法，返回一个指向ACE_Thread_Manager singleton的指针。|



ACE_Thread_Manager::spawn() 方法：




```cpp
  /**
   * Create a new thread, which executes @a func with argument @a arg.
   *
   * @param func        The function that is called in the spawned thread.
   *
   * @param arg         The value passed to each spawned thread's @a func.
   *
   * @param flags       Flags to control attributes of the spawned threads.
   *                    @sa ACE_OS::thr_create() for descriptions of the
   *                    possible flags values and their interactions.
   *
   * @param t_id        Pointer to a location to receive the spawned thread's
   *                    ID. If 0, the ID is not returned.
   *
   * @param t_handle    Pointer to a location to receive the spawned thread's
   *                    thread handle. If 0, the handle is not returned.
   *
   * @param priority    The priority at which the thread is spawned.
   *
   * @param grp_id      The thread group that the spawned thread is
   *                    added to. If -1 is specified, a new thread group is
   *                    created for the spawned thread.
   *
   * @param stack       Pointers to the base of a pre-allocated stack space
   *                    for the thread's stack. If 0, the platform allocates
   *                    stack space for the thread. If a stack is specified,
   *                    it is recommended that @a stack_size also be supplied
   *                    to specify the size of the stack.
   *                    Not all platforms support pre-allocated stacks. If
   *                    @a stack is specified for a platform which does not
   *                    allow pre-allocated stack space this parameter is
   *                    ignored.
   *
   * @param stack_size  Indicate how large the thread's stack should be, in
   *                    bytes. If a pre-allocated stack pointer is passed in
   *                    @a stack, @a stack_size indicates the size of that
   *                    stack area. If no pre-allocated stack is passed,
   *                    the stack size specified is passed to the
   *                    operating system to request that it allocate a stack
   *                    of the specified size.
   *
   * @param thr_name    Pointer to a name to assign to the spawned thread.
   *                    This is only meaningful for platforms that have a
   *                    capacity to name threads (e.g., VxWorks and some
   *                    varieties of Pthreads). This argument is ignored if
   *                    specified as 0 and on platforms that do not have the
   *                    capability to name threads.
   *
   * @retval   -1 on failure; @c errno contains an error value.
   * @retval   The group id of the spawned thread.
   */
  int spawn (ACE_THR_FUNC func,
             void *arg = 0,
             long flags = THR_NEW_LWP | THR_JOINABLE | THR_INHERIT_SCHED,
             ACE_thread_t *t_id = 0,
             ACE_hthread_t *t_handle = 0,
             long priority = ACE_DEFAULT_THREAD_PRIORITY,
             int grp_id = -1,
             void *stack = 0,
             size_t stack_size = ACE_DEFAULT_THREAD_STACKSIZE,
             const char** thr_name = 0);
```

我们可以向 spawn() 方法传递一组标志，用以指定“被创建线程”的属性。

|标志|说明|
|:---:|:---:|
|THR_SCOPE_SYSTEM|系统调度争用，与新核心线程绑定。|
|THR_SCOPE_PROCESS|进程调度争用，作为用户线程。|
|THR_NEW_LWP|进程的并发属性。“未绑定线程”：默认增1，添加一个核心线程到线程池以运行用户线程。|
|THR_DETACHED|创建“分离”线程。线程终止时ID和资源会被OS自动回收，与THR_JOINABLE标志相反。|
|THR_JOINABLE|创建“可连接”线程，其他线程可以通过ACE_Thread_Manager::join()方法得到它的退出状态。所有ACE线程创建方法的默认行为是THR_JOINABLE。|



示例：

定义 Thread_Per_Connection_Logging_Server 类：

```cpp
class Thread_Per_Connection_Logging_Server : public Logging_Server
{
private:
  struct Thread_Args {
    Thread_Args (Thread_Per_Connection_Logging_Server *lsp) : this_ (lsp) {}

    Thread_Per_Connection_Logging_Server *this_;
    ACE_SOCK_Stream logging_peer_;
  };
```



handle_connect() 接受一个连接，并把连接放进 thread_args 对象的 ACE_SOCK_Stream 属性中。然后通过 ACE_Thread_Manager singleton 创建一个新线程，用于处理新连接的客户。

```cpp
int
Thread_Per_Connection_Logging_Server::handle_connections ()
{
  std::unique_ptr<Thread_Args> thread_args (new Thread_Args (this));
  // accept a new connection
  if (acceptor ().accept (thread_args->logging_peer_) == -1)
    return -1;
  // spawn a thread to handle
  if (ACE_Thread_Manager::instance ()->spawn (
                   // Pointer to function entry point.
                  Thread_Per_Connection_Logging_Server::run_svc,
                   // <run_svc> parameter.必须转换为 void* ，以适用于 ACE 线程 API
                  static_cast<void *> (thread_args.get ()),
      			  // flags
                  THR_DETACHED | THR_SCOPE_SYSTEM) == -1)
    return -1;
  thread_args.release ();   // Spawned thread now owns memory
  return 0;
}
```

run_svc() 是每个新线程的入口点函数。底层 OS 会将thread_args 指针传递给 run_svc() ，用以控制 logging_peer 的生存期（动态分配）

```cpp
// Passed as a parameter to <ACE_Thread_Manager::spawn>.
static ACE_THR_FUNC_RETURN run_svc (void *arg);


ACE_THR_FUNC_RETURN Thread_Per_Connection_Logging_Server::run_svc (void *arg)
{
  std::unique_ptr<Thread_Args> thread_args (static_cast<Thread_Args *> (arg));

  thread_args->this_->handle_data (&thread_args->logging_peer_);
  thread_args->logging_peer_.close ();
  return 0;    // Return value is ignored
}
```

handle_data()

```cpp
int
Thread_Per_Connection_Logging_Server::handle_data (ACE_SOCK_Stream *client)
{
  ACE_FILE_IO log_file;
  // Client's hostname is logfile name.
  make_log_file (log_file, client);

  // Place the connection into blocking mode since this
  // thread isn't doing anything except handling this client.
  client->disable (ACE_NONBLOCK);

  Logging_Handler logging_handler (log_file, *client);

  // Keep handling log records until client closes connection
  // or this thread is asked to cancel itself.
  ACE_Thread_Manager *mgr = ACE_Thread_Manager::instance ();
  ACE_thread_t me = ACE_Thread::self ();
  // 协同式删除，缺点：只有在接收到下一个日志记录之后，线程才会注意到“删除请求”。解决：使用 ACE Reator 和 Task 框架。
  while (!mgr->testcancel (me) &&
         logging_handler.log_record () != -1)
    continue;

  log_file.close ();
  return 0;
}
```



main()

```cpp
int ACE_TMAIN (int argc, ACE_TCHAR *argv[])
{
  // Register to receive the <SIGTERM> signal.
  ACE_Sig_Action sa ((ACE_SignalHandler) sigterm_handler,
                     SIGTERM);

  Thread_Per_Connection_Logging_Server server;

  if (server.run (argc, argv) == -1)
    ACE_ERROR_RETURN ((LM_ERROR, "%p\n", "server.run()"), 1);

  // Cooperative thread cancellation and barrier synchronization.
  ACE_Thread_Manager::instance ()->cancel_all ();
  return ACE_Thread_Manager::instance ()->wait ();
}
```

main() 的最后一行是一个 wait() 调用，它允许日志服务器等待，以和所有“被删除线程”同步——栅栏同步( barrier synchronization )。







### 9.4 ACE_Sched_Params

ACE_Sched_Params 类接口

|方法|说明|
|:---:|:---:|
|ACE_Sched_Params()|设置线程的调度策略、优先级、范围和量|
|priority_min()|返回某一调度策略和范围的最低优先级|
|priority_max()|返回最高优先级|
|next_priority()|返回下一个较高的优先级|
|previous_priority()|返回下一个较低的优先级|

构造方法

```cpp
  // = Initialization and termination methods.
  /// Constructor.
                    // 调度策略
  ACE_Sched_Params (const Policy policy,
                    // 优先级
                    const ACE_Sched_Priority priority,
                    // 范围
                    const int scope = ACE_SCOPE_THREAD,
                    const ACE_Time_Value &quantum = ACE_Time_Value::zero);
```



示例：

重写open() ，默认情况下，被创建的线程会运行在最低的“实时”线程优先级上。如果缺乏权限就会退而运行在“分时”调度级别上。

```cpp
int
RT_Thread_Per_Connection_Logging_Server::open (u_short port)
{
  ACE_Sched_Params fifo_sched_params
    (ACE_SCHED_FIFO,
     ACE_Sched_Params::priority_min (ACE_SCHED_FIFO),
     ACE_SCOPE_PROCESS);

  if (ACE_OS::sched_params (fifo_sched_params) != 0) {
    if (errno == EPERM || errno == ENOTSUP)
      ACE_DEBUG ((LM_DEBUG,
                  "Warning: user's not superuser, so "
                  "we're running in time-shared class\n"));
    else
      ACE_ERROR_RETURN ((LM_ERROR,
                         "%p\n", "ACE_OS::sched_params()"), -1);
  }
  // Initialize the parent classes.
  return Thread_Per_Connection_Logging_Server::open (port);
}
```

重写handle_data()，提高每个处理data的线程的优先级：

```cpp
int
RT_Thread_Per_Connection_Logging_Server::handle_data (ACE_SOCK_Stream *client)
{
  int prio =
    ACE_Sched_Params::next_priority
        (ACE_SCHED_FIFO,
         ACE_Sched_Params::priority_min (ACE_SCHED_FIFO),
         ACE_SCOPE_THREAD);
  ACE_OS::thr_setprio (prio);
  return Thread_Per_Connection_Logging_Server::handle_data (client);
}
```





### 9.5 ACE_TSS

Thread Specific Storage ( TSS ) ：线程专有存储

线程专有存储应被用于这样的多线程应用：它们经常访问那些*逻辑上*是全局的、而*物理上*是专有于每个线程的对象。例如，errno 对象。像UNIX和Win32这样的操作系统使用errno来向应用报告错误信息。当错误在系统调用中发生时，OS设置errno来报告问题、并返回文档化的失败状态。当应用检测到失败时，它检查errno来确定发生了何种类型的错误。

特别地，占先式多线程系统中的条件竞争会导致一个线程中的方法所设置的 errno 值被另一线程中的应用错误地解释。在多线程应用中，全局版本的errno就有可能会由于条件竞争而被不正确地设置。



##### 优点：

**效率：**线程专有存储允许线程中的一系列方法原子地访问线程专有的对象，而又不会给每次访问带来锁定开销。

**简化应用编程：**对于应用程序员来说，线程专有存储易于使用，因为系统开发者可以通过数据抽象或宏来使线程专有存储的使用在源码级完全透明化。

**高度可移植：**线程专有存储在大多数多线程OS平台上都可用，并且可以在缺乏它的平台上（比如VxWorks）方便地实现。



在线程专有存储中，对象可像逻辑上的静态或全局变量一样被访问；而实际上（物理上）它对线程来说是私有的。把全局或静态数据放在TSS中，就可将同步所导致的开销降到最低。
|方法|说明|
|:---:|:---:|
|operator->()|得到“和TSS键相关联”的“线程专有”对象。|
|cleanup()|静态方法：线程退出时删除TSS对象。|



##### 适用性：

应用有以下特性时可使用线程专有存储：

　

- 应用最初的编写假定了单线程控制，并正在被移植到多线程环境，而又不能改变现有API
- 应用含有多个占先式线程控制，可以任意的调度顺序并发执行
- 每个线程控制调用一系列方法，这些方法共享只对该线程来说是公用的数据
- 在每个线程中被对象共享的数据必须通过一个全局可见的访问点来访问；该访问点“逻辑地”与其他线程共享，但在“物理上” 对于每个线程却是唯一的
- 数据在方法间隐式地传递，而不是经由参数显式地传递。





当应用有以下特性时，*不要*使用线程专有存储模式：

　

- 多个线程为单个任务协同工作，该任务需要并发访问共享数据。例如，多线程应用可以对在内存中的数据库并发地进行读写。在这样的情况下，线程必须共享不是线程专有的记录和表。如果使用线程专有存储来存储此数据库，线程就不能共享这些数据。因而，对数据库记录的访问必须通过同步原语（例如，互斥体）来控制，以使线程能在共享数据上协作。
- 维护物理和逻辑上都分离的数据要更为直观和高效。例如，通过将数据作为参数显式地传递给所有方法，有可能使线程访问仅在每个线程中可见的数据。在这样的情况下，线程专有存储模式有可能是不必要的。